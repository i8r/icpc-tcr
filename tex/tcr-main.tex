\documentclass[10pt,a4paper,ngerman]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[safe,warn]{textcomp}
\usepackage{tgtermes}
%\usepackage[scaled]{berasans}
\renewcommand*\ttdefault{txtt}
\usepackage{pdfpages}

\usepackage{babel}
\usepackage{xcolor}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{wasysym}

\usepackage{listings}

\usepackage{geometry}
\geometry{left=25mm,right=2cm, top=2cm, bottom=2cm}
\usepackage{multicol}
\setlength{\columnseprule}{.2pt}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Universität zu Lübeck, Ballmer Peak}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\title{Team Contest Reference\\ Ballmer Peak}
\author{Universität zu Lübeck}
\begin{document}
\lstset{
    xleftmargin= 8pt,
    breaklines     = true,
    basicstyle=\ttfamily\footnotesize,
    numbers=left,
    numberstyle=\tiny,
    tabsize=2,
    numbersep=5pt,
    columns=flexible,
    prebreak=\raisebox{0ex}[0ex][0ex]{\color{gray}{\DOWNarrow}}
}

\maketitle\thispagestyle{fancy}

\tableofcontents
\clearpage
\begin{multicols}{2}
\section{Mathematische Algorithmen}
\subsection{Primzahlen}
Für Primzahlen gilt immer (aber nicht nur für Primzahlen)
\[a^p\equiv a\mod p \quad\text{ bzw. }\quad a^{p-1}\equiv 1 \mod p.\]
Ein paar Primzahlen für den Hausgebrauch: $1000003, 2147483647 (2^{31}), 4294967291 (2^{32})$
\subsubsection{Sieb des Eratosthenes}
\lstinputlisting[language=Java]{eratosthenes.java}
\subsubsection{Primzahlentest}
\lstinputlisting[language=Java]{isprim.java}
\subsection{Binomial Koeffizient}
\lstinputlisting[language=Java]{binomial.java}
\subsection{Modulare Arithmetik}
Bedeutung der größten gemeinsamen Teiler:
\[ d = \text{ggT}(a,b) = as+bt \]
Verwendung zu Berechnung des inversen Elements $b$ zu $a$ bezüglich einer Restklassengruppe $n$ ($a$ und $n$ müssen teilerfremd sein):
\[ ab\equiv 1 \mod n \Leftrightarrow s\equiv b \mod n \text{ für }1=\text{ggT}(a,n)\]
\subsubsection{Erweiterter Euklidischer Algorithmus}
\lstinputlisting[language=Java]{eea.java}
Zur Berechnung des Inversen von $n$ im Restklassenring $p$ gilt: $d = \mathrm{eea}(p,n)$.
\subsection{Matrixmultiplikation}
Strassen-Algorithmus: $\mathbf{C} = \mathbf{A} \mathbf{B} \qquad \mathbf{A},\mathbf{B},\mathbf{C} \in R^{2^n \times 2^n}$
\begin{eqnarray*}
\mathbf{C}_{1,1} & =& \mathbf{A}_{1,1} \mathbf{B}_{1,1} + \mathbf{A}_{1,2} \mathbf{B}_{2,1} \\
\mathbf{C}_{1,2} &=& \mathbf{A}_{1,1} \mathbf{B}_{1,2} + \mathbf{A}_{1,2} \mathbf{B}_{2,2}\\
\mathbf{C}_{2,1} &=& \mathbf{A}_{2,1} \mathbf{B}_{1,1} + \mathbf{A}_{2,2} \mathbf{B}_{2,1} \\
\mathbf{C}_{2,2} &=& \mathbf{A}_{2,1} \mathbf{B}_{1,2} + \mathbf{A}_{2,2} \mathbf{B}_{2,2}
\end{eqnarray*}
\section{Datenstukturen}
\subsection{Fenwick Tree (Binary Indexed Tree)}
\lstinputlisting[language=Java]{fenwick.java}

\section{Graphenalgorithmen}
\subsection{Topologische Sortierung}
\lstinputlisting[language=Java]{toposort.java}
\subsection{Minimum Spanning Tree}
\subsubsection{Prim's Algorithm}
\lstinputlisting[language=c]{prim.c}
\subsubsection{Union and Find: Kruskal's Algorithm}
Amortized time per operation is~$O(\alpha(n))$.
\lstinputlisting[language=c]{unf.c}
\subsection{Maximaler Fluss (Ford-Fulkerson)}
\lstinputlisting[language=c]{flow.h}
\lstinputlisting[language=c]{flow.c}
%\lstinputlisting[language=c]{ford-fulkerson.c}
\lstinputlisting[language=java]{ford-fulkerson.java}
\subsection{Floyd-Warshall}
\lstinputlisting[language=java]{floyd.java}
\subsection{Dijkstra}
\lstinputlisting[language=java]{dijkstra.java}
\subsection{Bellmann-Ford}
Single source all paths, negative weights.
\lstinputlisting[language=java]{bellmann-ford.java}
\subsection{Starke Zusammenhangskomponenten (Kosaraju)}
\lstinputlisting[language=c]{Kosaraju.c}

\section{Geometrische Algorithmen}
\subsection{Rotate a Point}
\lstinputlisting[language=java]{rotate.java}
\subsection{Distanz zwischen Geradensegment und Punkt}
\lstinputlisting[language=java]{distlinepoint.java}
\subsection{Line Intersection}
\lstinputlisting[language=java]{intersects.java}
\subsection{Graham Scan (Convex Hull)}
\lstinputlisting[language=java]{graham.java}
\subsection{Maximum Distance in a Point Set}
\lstinputlisting[language=java]{maxdist.java}
\subsection{Area of a Polygon}
\lstinputlisting[language=java]{areapolygon.java}
\subsection{Punkt in Polygon}
\lstinputlisting[language=java]{PointInPoly.java}

\section{Textsuche}
\subsection{Knuth-Morris-Pratt}
\lstinputlisting[language=java]{KMP.java}

\section{Verschiedenes}
\subsection{Potenzmenge}
\lstinputlisting[language=java]{powerset.java}
\subsection{Longest Common Subsequence}
\lstinputlisting[language=c]{longest_common_subsequence.c}
\subsection{Longest Increasing Subsequence}
\lstinputlisting[language=c]{longest_increasing_subsequence.c}
\subsection{CYK-Algorithmus}
\begin{lstlisting}
let the input be a string S consisting of n characters: a1 ... an.
let the grammar contain r nonterminal symbols R1 ... Rr.
This grammar contains the subset Rs which is the set of start symbols.
let P[n,n,r] be an array of booleans. Initialize all elements of P to false.
for each i = 1 to n
  for each unit production Rj -> ai
    set P[i,1,j] = true
for each i = 2 to n -- Length of span
  for each j = 1 to n-i+1 -- Start of span
    for each k = 1 to i-1 -- Partition of span
      for each production RA -> RB RC
        if P[j,k,B] and P[j+k,i-k,C] then set P[j,i,A] = true
if any of P[1,n,x] is true (x is iterated over the set s, where s are all the indices for Rs) then
  S is member of language
else
  S is not member of language
\end{lstlisting}
\section{Eine kleine C-Referenz}
\end{multicols}

\includepdf[
	scale=0.9,
	angle=90,
	pages=1,
	pagecommand={		
}]{c-refcard.pdf}

\includepdf[
	scale=0.9,
	angle=90,
	pages=2,
	pagecommand={		
}]{c-refcard.pdf}

\includepdf[
	scale=0.9,
	pages=1-10,
	pagecommand={		
}]{TCS-CheatSheet.pdf}


\end{document}
